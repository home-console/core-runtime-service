# Контракт Remote Plugin
## Формальная спецификация взаимодействия Core Runtime ↔ Remote Plugin

**Статус:** Формализован  
**Основан на:** реализациях `remote_logger`, `remote_metrics`  
**Версия:** 1.0

---

## Содержание

1. [Краткое резюме](#краткое-резюме)
2. [Обзор архитектуры](#обзор-архитектуры)
3. [Контракт жизненного цикла плагина](#контракт-жизненного-цикла-плагина)
4. [Регистрация и вызов сервисов](#регистрация-и-вызов-сервисов)
5. [Матрица ответственности](#матрица-ответственности)
6. [Ограничения и запреты](#ограничения-и-запреты)
7. [Обработка ошибок и отказоустойчивость](#обработка-ошибок-и-отказоустойчивость)
8. [Чеклист проверки перед SDK](#чеклист-проверки-перед-sdk)

---

## Краткое резюме

Этот документ формализует HTTP-based контракт между Core Runtime и remote plugins.

**Ключевые инварианты:**
- Core Runtime **не изменяется** при интеграции remote plugins
- Remote plugins управляются через HTTP lifecycle endpoints
- Сервисы объявляются в metadata и автоматически регистрируются proxy
- Сбой remote plugin **не должен** приводить к сбою Core Runtime

**Область применения:** Только system plugins (remote_logger, remote_metrics и т.д.). Domain plugins остаются in-process.

---

## Обзор архитектуры

### Взаимодействие компонентов

```
┌─────────────────────────┐
│   Core Runtime          │
│  - PluginManager        │
│  - ServiceRegistry      │
│  - EventBus, etc.       │
└───────────┬─────────────┘
            │ (lifecycle methods)
            │ (service calls)
            ▼
┌─────────────────────────┐
│  RemotePluginProxy      │
│  (local plugin in Core) │
│  - HTTP forwarder       │
│  - service registration │
└───────────┬─────────────┘
            │ (HTTP POST/GET)
            │
    ┌───────┴──────────┐
    │   Network        │
    └───────┬──────────┘
            │
            ▼
┌─────────────────────────┐
│  Remote Plugin (Process)│
│  - HTTP endpoints       │
│  - business logic       │
│  - state management     │
└─────────────────────────┘
```

### Поток данных

```
1. Загрузка плагина:
   Core → PluginManager.load_plugin(RemotePluginProxy)
   RemotePluginProxy.on_load():
     → GET  /plugin/metadata
     → POST /plugin/load
     → register services from metadata.services

2. Вызов сервиса:
   Core → ServiceRegistry.call("metrics.report", args)
   ServiceRegistry → registered forwarder
   forwarder → RemotePluginProxy → POST /metrics/report (payload)
   Remote plugin обрабатывает, возвращает ответ

3. Остановка плагина:
   Core → PluginManager.stop_plugin(name)
   RemotePluginProxy.on_stop():
     → POST /plugin/stop

4. Выгрузка плагина:
   Core → PluginManager.unload_plugin(name)
   RemotePluginProxy.on_unload():
     → POST /plugin/unload
     → unregister all services from metadata.services
```

---

## Контракт жизненного цикла плагина

### Lifecycle Endpoints (обязательные)

Каждый remote plugin **должен** реализовать следующие HTTP endpoints:

#### `GET /plugin/metadata`

**Назначение:** Объявить возможности плагина, имя, версию и доступные сервисы.

**Ответ (JSON):**
```json
{
  "name": "string",              // Обязательно: идентификатор плагина (например, "remote_logger")
  "type": "string",              // Обязательно: "system" или "domain"
  "mode": "string",              // Обязательно: "remote"
  "version": "string",           // Обязательно: семантическая версия (например, "0.1.0")
  "description": "string",       // Опционально: человекочитаемое описание
  "author": "string",            // Опционально: автор/поддерживающий плагин
  "services": [                  // Обязательно (может быть пустым массивом)
    {
      "name": "string",          // Обязательно: идентификатор сервиса (например, "metrics.report")
      "endpoint": "string",      // Обязательно: HTTP endpoint (например, "/metrics/report")
      "method": "string"         // Обязательно: "GET" или "POST"
    }
  ]
}
```

**Коды статуса:**
- `200`: Metadata предоставлен (даже в состоянии ошибки)
- `500`: Критическая ошибка (например, плагин упал)

**Идемпотентность:** Да. Должен возвращать те же данные при повторных вызовах.

**Примечания:**
- Ответ читается один раз во время `on_load()` proxy
- Proxy использует `metadata.services` для автоматической регистрации локальных forwarders
- Имя в metadata **должно** соответствовать ожиданиям PluginManager

---

#### `GET /plugin/health`

**Назначение:** Проверить работоспособность remote plugin (опционально, но рекомендуется).

**Ответ (JSON):**
```json
{
  "status": "ok" | "error",
  "loaded": boolean,
  "started": boolean,
  "timestamp": "ISO8601"
}
```

**Коды статуса:**
- `200`: Health data предоставлен
- `503`: Сервис недоступен (временно)

**Идемпотентность:** Да.

**Примечания:**
- Используется для диагностики, не требуется для lifecycle
- Proxy может логировать это во время переходов lifecycle (будущее улучшение)

---

#### `POST /plugin/load`

**Назначение:** Инициализировать состояние плагина, подготовить ресурсы, объявить сервисы (без активации).

**Запрос:** Тело не требуется.

**Ответ (JSON):**
```json
{
  "status": "ok" | "already loaded" | "error",
  "message": "string"  // Опционально
}
```

**Коды статуса:**
- `200`: Успешно загружен (или уже был загружен)
- `500`: Критическая ошибка

**Идемпотентность:** Да.  
- Если уже загружен, вернуть `{"status": "already loaded"}` (HTTP 200)
- Не выдавать ошибку при повторных вызовах

**Гарантия порядка:**
- Вызывается **перед** `/plugin/start`
- Вызывается **один раз на экземпляр плагина** (если явно не выгружен)

**Обязанности Remote Plugin:**
- Выделить ресурсы (память, файловые дескрипторы, соединения)
- Валидировать конфигурацию
- **НЕ** запускать фоновые задачи или слушать внешние события

**Поведение Proxy:**
- Вызывает сразу после `/plugin/metadata`
- При ошибке: выбрасывает исключение, блокирует загрузку Core

---

#### `POST /plugin/start`

**Назначение:** Активировать плагин, запустить фоновые задачи, включить service endpoints.

**Запрос:** Тело не требуется.

**Ответ (JSON):**
```json
{
  "status": "ok" | "already started" | "error",
  "message": "string"  // Опционально
}
```

**Коды статуса:**
- `200`: Запущен (или уже был запущен)
- `500`: Критическая ошибка

**Идемпотентность:** Да.  
- Если уже запущен, вернуть `{"status": "already started"}` (HTTP 200)

**Гарантия порядка:**
- Вызывается **после** `/plugin/load`
- Вызывается **один раз за цикл Core runtime**

**Обязанности Remote Plugin:**
- Запустить слушателей событий
- Начать обслуживать service endpoints
- Service endpoints теперь могут получать запросы

**Поведение Proxy:**
- Вызывается через `PluginManager.start_plugin(name)`
- При ошибке: состояние плагина = ERROR

---

#### `POST /plugin/stop`

**Назначение:** Корректно деактивировать плагин, приостановить фоновые задачи, прекратить принимать новые вызовы сервисов.

**Запрос:** Тело не требуется.

**Ответ (JSON):**
```json
{
  "status": "ok" | "already stopped" | "error",
  "message": "string"  // Опционально
}
```

**Коды статуса:**
- `200`: Остановлен (или уже был остановлен)
- `500`: Критическая ошибка

**Идемпотентность:** Да.  
- Если уже остановлен, вернуть `{"status": "already stopped"}` (HTTP 200)

**Гарантия порядка:**
- Вызывается **после** `/plugin/start`
- Вызывается **один раз за цикл shutdown**

**Обязанности Remote Plugin:**
- Прекратить слушать события
- Позволить завершиться выполняющимся запросам
- Не принимать новые вызовы сервисов
- Освободить временные ресурсы (буферы, кеши)

**Поведение Proxy:**
- Вызывается через `PluginManager.stop_plugin(name)`
- Ошибки логируются, но не блокируют выгрузку

---

#### `POST /plugin/unload`

**Назначение:** Финальная очистка, освобождение всех ресурсов, подготовка к завершению.

**Запрос:** Тело не требуется.

**Ответ (JSON):**
```json
{
  "status": "ok" | "error",
  "message": "string"  // Опционально
}
```

**Коды статуса:**
- `200`: Выгружен
- `500`: Критическая ошибка

**Идемпотентность:** Да.  
- После выгрузки плагин больше не обслуживает запросы
- Последующие вызовы могут вернуть ошибку (приемлемо)

**Гарантия порядка:**
- Вызывается **после** `/plugin/stop` (обеспечивается proxy)
- Вызывается **один раз за время жизни плагина**

**Обязанности Remote Plugin:**
- Закрыть все соединения с БД/файлами
- Освободить всю память
- Сбросить буферы
- Подготовиться к завершению процесса

**Поведение Proxy:**
- Вызывает сразу перед выгрузкой из Core
- При успехе: отменяет регистрацию всех сервисов из ServiceRegistry
- При ошибке: логирует ошибку, всё равно отменяет регистрацию сервисов (чтобы предотвратить коррупцию реестра)

---

## Регистрация и вызов сервисов

### Объявление сервисов (metadata.services)

Remote plugins объявляют доступные сервисы в ответе `/plugin/metadata`.

**Схема:**
```json
{
  "name": "service.identifier",    // например, "metrics.report", "logger.log"
  "endpoint": "/relative/path",    // например, "/metrics/report"
  "method": "POST" | "GET"         // HTTP метод
}
```

**Требования:**
- `name` должен быть **уникальным в Core ServiceRegistry**
- `name` должен следовать паттерну: `namespace.action` (например, `metrics.report`)
- `endpoint` должен быть относительным к базовому URL remote plugin
- `method` определяет HTTP метод, используемый proxy

**Поведение Proxy:**
- При `on_load()`: читает `metadata.services`
- Для каждого сервиса: создаёт async forwarder функцию
- Регистрирует forwarder через `runtime.service_registry.register(name, forwarder)`
- При `on_unload()`: отменяет регистрацию всех forwarders

### Вызов сервисов (Proxy ↔ Remote)

#### Формат запроса

**Proxy перенаправляет локальный вызов сервиса на remote endpoint:**

```
POST /endpoint
Content-Type: application/json

{
  "args": [],           // позиционные аргументы (обычно пусто для kwargs-only вызовов)
  "kwargs": {           // именованные аргументы от вызывающего
    "key": "value",
    "param2": 123
  }
}
```

**Пример (вызов metrics.report):**
```
Вызывающий:
  await runtime.service_registry.call(
    "metrics.report",
    name="cpu_usage",
    value=0.42,
    tags={"host": "server1"}
  )

Proxy преобразует в HTTP запрос:
  POST http://remote:8002/metrics/report
  {
    "args": [],
    "kwargs": {
      "name": "cpu_usage",
      "value": 0.42,
      "tags": {"host": "server1"}
    }
  }
```

#### Формат ответа

**Remote plugin должен вернуть JSON:**

```json
{
  "status": "ok",            // Обязательно: "ok" для успеха
  // Любые дополнительные поля специфичны для приложения
}
```

**Коды статуса:**
- `200`: Сервис выполнен успешно
- `400`: Неверные параметры (bad request)
- `500`: Ошибка сервиса (internal server error)
- `503`: Сервис недоступен (плагин не запущен)

**Поведение Proxy при ответе:**
- Статус 200 → возвращает распарсенный JSON вызывающему
- Статус 4xx/5xx → выбрасывает исключение (пробрасывает вызывающему)
- Таймаут (нет ответа) → выбрасывает исключение

#### GET Service Endpoints (опционально)

Если `method` = "GET", proxy игнорирует kwargs и вызывает:
```
GET /endpoint
```

Ответ такой же, как у POST (JSON с `{"status": "ok", ...}`).

**Случай использования:** операции только для чтения (например, health check, дамп метрик).

---

## Матрица ответственности

| Аспект | Remote Plugin | Proxy | Core Runtime |
|--------|---------------|-------|--------------|
| **HTTP Server** | ✅ Должен реализовать | ❌ Нет | ❌ Нет |
| **Lifecycle Endpoints** | ✅ Должен реализовать | ✅ Вызывает | ❌ Не знает |
| **Service Endpoints** | ✅ Должен реализовать | ✅ Перенаправляет | ❌ Не знает |
| **Metadata Declaration** | ✅ Должен предоставить | ✅ Читает один раз | ❌ Не знает |
| **Service Registration** | ❌ Нет | ✅ Регистрирует | ❌ Не знает |
| **Error Handling** | ✅ Возвращает HTTP ошибку | ✅ Логирует и пробрасывает | ✅ Обрабатывает исключения |
| **State Management** | ✅ Поддерживает (load/start/stop/unload) | ❌ Нет | ❌ Не знает |
| **Timeout Handling** | ✅ Возвращает в пределах таймаута | ✅ Реализует логику таймаута | ❌ Не знает |
| **Logging** | ✅ Может логировать локально | ✅ Логирует ошибки proxy | ✅ Логирует ошибки обработчиков |
| **Graceful Shutdown** | ✅ Сбрасывает выполняющиеся запросы | ✅ Вызывает /plugin/stop сначала | ✅ Вызывает методы plugin manager |

---

## Ограничения и запреты

### Явно запрещено

1. **Ad-hoc кодирование параметров**  
   ❌ ЗАПРЕЩЕНО: Разные реализации proxy изобретают разные форматы `{args, kwargs}`  
   ✅ ТРЕБУЕТСЯ: Все proxy используют стандартизированный формат `{"args": [], "kwargs": {...}}` (как определено выше)

2. **Изменения Core Runtime**  
   ❌ ЗАПРЕЩЕНО: Добавление новых методов Core для поддержки remote plugins  
   ✅ ТРЕБУЕТСЯ: Remote plugins используют существующие Core API (ServiceRegistry, PluginManager и т.д.)

3. **Прямая регистрация Service Endpoints**  
   ❌ ЗАПРЕЩЕНО: Remote plugin напрямую вызывает `runtime.service_registry.register()`  
   ✅ ТРЕБУЕТСЯ: Сервисы объявляются в metadata; proxy автоматически регистрирует их

4. **Неявное управление зависимостями**  
   ❌ ЗАПРЕЩЕНО: Remote plugin предполагает существование других сервисов без проверки lifecycle  
   ✅ ТРЕБУЕТСЯ: Remote plugin корректно обрабатывает отсутствующие зависимости в runtime

5. **Версионирование через переговоры**  
   ❌ ЗАПРЕЩЕНО: Proxy и remote договариваются о версиях API на лету  
   ✅ ТРЕБУЕТСЯ: Версия в metadata только информационная; proxy обрабатывает все remotes одинаково

6. **Аутентификация/Авторизация**  
   ❌ ЗАПРЕЩЕНО: Добавление auth к HTTP endpoints remote plugin  
   ✅ ТРЕБУЕТСЯ: Сетевая изоляция (только локальные URL) достаточна для MVP

7. **Нарушение идемпотентности Lifecycle**  
   ❌ ЗАПРЕЩЕНО: Remote plugin падает при двойном вызове (например, `POST /plugin/load` дважды)  
   ✅ ТРЕБУЕТСЯ: Lifecycle endpoints должны быть идемпотентными (см. [Контракт жизненного цикла](#контракт-жизненного-цикла-плагина))

---

## Обработка ошибок и отказоустойчивость

### Сценарии сбоев

#### Сценарий 1: Remote Plugin падает во время загрузки

```
Proxy.on_load() вызывает GET /plugin/metadata → timeout/connection refused
Proxy: логирует ошибку, пробрасывает исключение
PluginManager: ловит исключение, устанавливает состояние плагина = ERROR
Результат: Плагин не загружен, Core продолжает работу
```

**Поведение:**
- Core НЕ падает
- Другие плагины загружаются нормально
- Неудачный плагин остаётся в состоянии ERROR

#### Сценарий 2: Remote Plugin никогда не вызывает `/plugin/start`

```
Proxy.on_start() вызывает POST /plugin/start → возвращает 500 ошибку
Proxy: логирует ошибку, пробрасывает исключение
PluginManager: ловит исключение, устанавливает состояние плагина = ERROR
Результат: Сервис зарегистрирован, но endpoints возвращают ошибки
```

**Поведение:**
- Core НЕ падает
- Сервисы доступны для вызова (обратная совместимость)
- Вызовы сервисов к remote endpoint будут падать (сетевая/remote ошибка)

#### Сценарий 3: Remote Plugin падает во время вызова сервиса

```
Вызывающий: await runtime.service_registry.call("metrics.report", ...)
Proxy forwarder: отправляет POST /metrics/report → timeout
Proxy: выбрасывает исключение (сетевая ошибка)
Вызывающий: ловит исключение
Результат: Этот вызов сервиса падает, но Core/proxy остаются живы
```

**Поведение:**
- Вызов выбрасывает исключение вызывающему
- Вызывающий должен обработать исключение
- Proxy и Core не затронуты
- Другие вызовы сервисов продолжают работать нормально

#### Сценарий 4: Remote Plugin падает во время Stop/Unload

```
Proxy.on_stop() вызывает POST /plugin/stop → timeout
Proxy: логирует ошибку, подавляет исключение
PluginManager: состояние плагина = STOPPED (частично)
Результат: Плагин помечен как остановленный, но remote может всё ещё работать
```

**Поведение:**
- Ошибки stop логируются, но НЕ блокируют lifecycle
- Выгрузка продолжается в любом случае
- Сервисы отменяются даже если unload падает
- Core помечает плагин как выгруженный

### Поведение при таймауте

**Текущая реализация (urllib):**
- Блокирующие HTTP вызовы без явного таймаута
- Долгие операции могут зависнуть

**Обязанность Proxy:**
- Реализовать таймаут в HTTP слое (будущее: добавить `socket.settimeout()`)
- Таймаут должен быть настроен или по умолчанию 5 секунд

**Обязанность Remote Plugin:**
- Все lifecycle endpoints должны отвечать в течение 1 секунды
- Service endpoints могут занимать больше времени (до таймаута)

---

## Чеклист проверки перед SDK

Перед релизом SDK на основе этого контракта, проверить:

### ✅ Идемпотентность жизненного цикла
- [ ] Тест: Вызвать `/plugin/load` дважды → оба возвращают `{"status": "ok"}` (HTTP 200)
- [ ] Тест: Вызвать `/plugin/start` дважды → оба возвращают `{"status": "ok"}` (HTTP 200)
- [ ] Тест: Вызвать `/plugin/stop` дважды → оба возвращают `{"status": "ok"}` (HTTP 200)
- [ ] Тест: Вызвать `/plugin/unload` на незагруженном плагине → корректная ошибка (HTTP 200 или 400, не 500)

### ✅ Регистрация и вызов сервисов
- [ ] Тест: Metadata объявляет 2+ сервиса → все зарегистрированы в ServiceRegistry
- [ ] Тест: Вызов сервиса с kwargs → proxy перенаправляет как `{"kwargs": {...}}`
- [ ] Тест: Service endpoint возвращает кастомный JSON → передаётся вызывающему
- [ ] Тест: Service endpoint возвращает 500 → proxy выбрасывает исключение вызывающему

### ✅ Изоляция ошибок
- [ ] Тест: Remote plugin падает → Core runtime продолжает работу
- [ ] Тест: Таймаут сети proxy → исключение залогировано, вызывающий информирован (не падение Core)
- [ ] Тест: Remote /plugin/load падает → другие плагины всё равно загружаются
- [ ] Тест: Вызов сервиса падает → другие сервисы всё равно вызываемы

### ✅ Порядок жизненного цикла
- [ ] Тест: Вызвать `/plugin/start` перед `/plugin/load` → ошибка или корректный отказ
- [ ] Тест: Вызвать сервис перед `/plugin/start` → ошибка или HTTP 503
- [ ] Тест: Unload → сервисы отменены (не вызываемы после этого)

### ✅ Валидность Metadata
- [ ] Тест: Metadata без поля `name` → proxy обрабатывает корректно
- [ ] Тест: Service `endpoint` невалиден или недоступен → proxy логирует ошибку, сервис падает при вызове
- [ ] Тест: Service `name` конфликтует с существующим сервисом → proxy логирует предупреждение, регистрация может упасть

### ✅ Конкурентность и race conditions
- [ ] Тест: Два конкурентных вызова одного сервиса → оба выполняются независимо
- [ ] Тест: Конкурентные `/plugin/stop` и вызов сервиса → вызов сервиса падает корректно, stop успешен
- [ ] Тест: Регистрация сервиса + немедленный вызов → без гонок (сервис должен быть вызываем после возврата on_load)

### ✅ Консистентность HTTP контракта
- [ ] Тест: Два разных remote plugin (logger, metrics) → одинаковые сигнатуры lifecycle endpoints
- [ ] Тест: Формат запроса консистентен (GET без тела, POST с JSON телом)
- [ ] Тест: Формат ответа консистентен (все возвращают JSON с полем `status`)

### ✅ Документация и обнаружение
- [ ] Валидация схемы: список metadata.services синтаксически валиден
- [ ] Proxy логирует URL endpoints для отладки
- [ ] Сообщения об ошибках включают имя endpoint и HTTP статус

---

## Приложение: Референсные реализации

### Шаблон Remote Plugin (минимальный)

```python
from fastapi import FastAPI, HTTPException

_state = {"loaded": False, "started": False}
app = FastAPI()

@app.get("/plugin/metadata")
async def metadata():
    return {
        "name": "my_plugin",
        "type": "system",
        "mode": "remote",
        "version": "0.1.0",
        "services": [
            {"name": "my.service", "endpoint": "/my/service", "method": "POST"}
        ]
    }

@app.post("/plugin/load")
async def load():
    if _state["loaded"]:
        return {"status": "already loaded"}
    _state["loaded"] = True
    return {"status": "ok"}

@app.post("/plugin/start")
async def start():
    if not _state["loaded"]:
        raise HTTPException(500, "not loaded")
    if _state["started"]:
        return {"status": "already started"}
    _state["started"] = True
    return {"status": "ok"}

@app.post("/plugin/stop")
async def stop():
    if not _state["started"]:
        return {"status": "already stopped"}
    _state["started"] = False
    return {"status": "ok"}

@app.post("/plugin/unload")
async def unload():
    _state["loaded"] = False
    return {"status": "ok"}

@app.post("/my/service")
async def my_service(request):
    body = await request.json()
    kwargs = body.get("kwargs", {})
    # Обработать вызов сервиса
    return {"status": "ok", "result": ...}
```

### Ожидания Proxy

Proxy (класс `RemotePluginProxy`) ожидает:
1. HTTP GET `/plugin/metadata` доступен до lifecycle
2. Идемпотентные lifecycle endpoints (load, start, stop, unload)
3. Service endpoints отвечают в пределах таймаута (5s по умолчанию)
4. Все ответы — JSON с полем верхнего уровня `"status"`
5. HTTP 200 = успех или already-done, HTTP 5xx = ошибка

---

## Заключение

Этот контракт формализует проверенный паттерн `remote_logger` и `remote_metrics`.

**Резюме:**
- **Core неизменен:** Только proxy и remote plugin используют HTTP
- **Lifecycle ясен:** load → start → stop → unload (все идемпотентны)
- **Сервисы объявлены:** metadata.services → автоматически зарегистрированы → вызываемы
- **Сбои изолированы:** Ошибки remote не крашат Core
- **Расширяем:** Новые remote plugins используют тот же контракт

**Следующие шаги для SDK:**
1. Кодифицировать этот контракт в документации SDK
2. Предоставить шаблон + инструменты валидации
3. Протестировать на 3+ различных реализациях remote plugin
4. Установить HTTP клиентскую библиотеку (таймаут, retry, логирование)
