## Назначение
CoreRuntime предоставляет минимальный набор примитивов для плагинов.  
Core не знает домена, интеграций, UI и бизнес-логики.

---

## RuntimeModule vs Plugin

### RuntimeModule (обязательные домены)

**Что это:**
- Обязательные домены системы, которые всегда доступны
- Расширяют ядро Core, но не являются частью Core
- Регистрируются напрямую в CoreRuntime через ModuleManager
- Не зависят от PluginManager

**Примеры:**
- `logger` — инфраструктурный модуль логирования
- `api` — HTTP API Gateway
- `admin` — административные endpoints
- `devices` — управление устройствами
- `automation` — автоматизация
- `presence` — отслеживание присутствия

**Гарантии:**
- REQUIRED модули обязательны для работы runtime
- Runtime НЕ стартует, если хоть один REQUIRED модуль:
  - не зарегистрировался
  - не смог выполниться register()
  - упал в start()
- OPTIONAL модули могут отсутствовать или фейлиться без остановки runtime

**Контракт Lifecycle:**
- `register()` вызывается ровно один раз при регистрации модуля
- `start()` вызывается ровно один раз при runtime.start()
- `stop()` вызывается ровно один раз при runtime.stop()
- Порядок: `__init__` → `register()` → `start()` → `stop()`
- `stop()` вызывается даже при частичном старте (если start() упал)

**Контракт Idempotency:**
- `register()` должен быть идемпотентным (повторные вызовы безопасны)
- ModuleManager защищает от двойной регистрации одного имени
- Один экземпляр модуля может быть зарегистрирован только один раз

**Различие REQUIRED vs OPTIONAL:**
- REQUIRED модули: logger, api, admin, devices, automation, presence
- OPTIONAL модули: могут быть добавлены в будущем
- REQUIRED модули не могут быть пропущены при ошибках
- OPTIONAL модули могут фейлиться без остановки runtime

### Plugin (опциональные расширения)

**Что это:**
- Опциональные расширения, которые можно включать/выключать
- Регистрируются через PluginManager
- Наследуются от BasePlugin
- Могут использовать RuntimeModule через ServiceRegistry/EventBus

**Загрузка:**
- Плагины загружаются ТОЛЬКО через manifest (plugin.json или manifest.json)
- PluginManager.auto_load_plugins() сканирует каталог plugins/ и загружает плагины на основе manifest
- Без manifest плагин не загружается
- Зависимости разрешаются автоматически через топологическую сортировку

**Доверие и изоляция:**
- Все плагины считаются доверенными
- Плагины выполняются в том же процессе, что и runtime
- Плагины имеют полный доступ к Core API
- Система НЕ реализует изоляцию или sandbox для плагинов

**Примеры:**
- `yandex_smart_home` — интеграция с Яндекс.Умный дом
- `oauth_yandex` — OAuth авторизация
- `client_manager` — управление клиентами

**Гарантии:**
- Плагины опциональны — система работает без них
- Ошибки в плагинах не останавливают runtime
- Плагины могут быть загружены/выгружены динамически

**Различие:**
- RuntimeModule — обязательное расширение ядра
- Plugin — опциональное расширение
- Runtime не может работать без REQUIRED RuntimeModule
- Runtime может работать без плагинов

---

## EventBus

### Гарантии
- асинхронная публикация/подписка (pub/sub)
- ошибки хендлеров не крашат рантайм

Дополнительные уточнения:
- обработчики вызываются асинхронно и выполняются параллельно (запускаются как независимые asyncio-задачи);
- порядок доставки/выполнения НЕ гарантируется;
- Core перехватывает исключения из обработчиков, предотвращает падение рантайма и не выполняет повторных попыток; логирование таких исключений зависит от доступной конфигурации логгера или плагина логгирования.

### Негиарантии
- упорядочивание
- устойчивость (persistence)
- повторные попытки (retries)

Явно: Core НЕ гарантирует упорядоченную доставку, постоянную (персистентную) доставку, повторные попытки или транзакционную доставку событий.

---

## ServiceRegistry

### Гарантии
- регистрация асинхронных/синхронных вызываемых объектов (callables)
- вызов по имени
- ошибки распространяются к вызывающему

Дополнительные уточнения:
- `register` принимает как синхронные, так и асинхронные вызываемые объекты; асинхронные вызываемые объекты (корутины) `await`-ятся при вызове через `call`.
- ошибки, возникающие в сервисе, пробрасываются к вызывающему в неизменённом виде (Core не оборачивает и не повторяет их).
- регистрация уже существующего имени сервиса вызывает исключение (текущее поведение: дубликат регистрации отклоняется).

### Негиарантии
- версионирование
- идемпотентность
- повторные попытки

Явно: Core НЕ предоставляет версионирование сервисов или разрешение конфликтов имён — именование и совместимость лежат на ответственности плагинов.

---

## Storage

### Гарантии
- асинхронное key-value хранилище по namespace
- персистентность через адаптер

Дополнительные уточнения:
- атомарность гарантируется только для одиночной операции namespace+key (`set`/`delete`); операции над несколькими ключами (например: множественные `set`/`delete`) и `list_keys` НЕ являются транзакционными и могут наблюдать промежуточные состояния при конкурентном доступе.
- гарантии надёжности (fsync, журналирование и т.п.) зависят от выбранного `StorageAdapter`; Core ожидает завершения адаптера, но не изменяет его гарантий надёжности.

### Негиарантии
- валидация схемы
- транзакции

Явно: Core НЕ предоставляет многоключевые транзакции или валидацию схемы; координация для согласованности при операциях над несколькими ключами — ответственность плагинов или адаптеров.

---

## StateEngine

### Гарантии
- состояние рантайма только для чтения
- обновляется автоматически CoreRuntime

Дополнительные уточнения:
- `StateEngine` — это in-memory, доступный только для чтения кэш / слой координации. Он обновляется Core в ответ на события хранения и является в конечном итоге согласованным с `Storage`.
- `StateEngine` НЕ является источником истины; чтения из `StateEngine` могут не отражать самое последнее значение в `Storage` сразу после `storage.set`.

### Негиарантии
- персистентность
- бизнес-согласованность

Явно: Core НЕ использует `StateEngine` для долговременного бизнес-хранилища или валидации — плагины должны использовать `Storage` для авторитетных данных.

---

## Жизненный цикл (Lifecycle)

- Core вызывает хук жизненного цикла плагинов (`on_load`, `on_start`, `on_stop`, `on_unload`) но не накладывает таймаутов. Долгие или блокирующие операции в хукaх жизненного цикла — ответственность автора плагина (плагины должны сами порождать фоновые задачи при необходимости и управлять их завершением).

---

## Отрицательные гарантии (явно)

- Core НЕ гарантирует порядок доставки событий.
- Core НЕ предоставляет повторных попыток при доставке событий или вызове сервисов.
- Core НЕ предоставляет персистентные очереди, версионирование событий/сервисов или многоключевые транзакции в хранилище.
- Core НЕ выполняет валидацию схем или бизнес-логику.
- Именование и совместимость контрактов для событий и сервисов управляются плагинами; Core не производит автоматическую неймспейсинг или версионирование.
- Core НЕ реализует изоляцию выполнения для плагинов — все плагины выполняются в том же процессе и считаются доверенными.